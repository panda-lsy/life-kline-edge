/**
 * AI 客户端测试
 * 测试 AI 服务调用的各种场景
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { AIClient, createAIClient, getDefaultClient, quickAnalyze } from '../aiClient';
import type { BaziResult } from '@/types';

// Mock fetch
const mockFetch = vi.fn();
global.fetch = mockFetch as any;

// 使用自定义 API 密钥进行测试
const testApiKey = 'test-api-key-12345';

// Mock test data
const mockBaziResult: BaziResult = {
  year: 1990,
  month: 1,
  day: 1,
  hour: 12,
  minute: 0,
  gender: 'male',
  siZhu: {
    year: { gan: '己', zhi: '巳' },
    month: { gan: '丙', zhi: '寅' },
    day: { gan: '甲', zhi: '子' },
    hour: { gan: '庚', zhi: '午' },
  },
  wuXing: {
 金: 20, 木: 30, 水: 10, 火: 25, 土: 15 },
  daYun: {
    startAge: 2,
    direction: 'forward',
    cycles: [],
  },
};

const mockAIResponse = {
  klineData: Array.from({ length: 100 }, (_, i) => ({
    year: 1990 + i,
    open: 50,
    close: 50 + Math.random() * 10,
    high: 60,
    low: 40,
  })),
  dimensions: {
    career: { score: 75, overview: '事业不错', details: ['工作稳定'], advice: ['继续努力'] },
    wealth: { score: 70, overview: '财运良好', details: ['收入稳定'], advice: ['合理理财'] },
    marriage: { score: 80, overview: '婚姻美满', details: ['感情和谐'], advice: ['珍惜彼此'] },
    health: { score: 72, overview: '健康良好', details: ['身体不错'], advice: ['注意休息'] },
    personality: { score: 78, overview: '性格开朗', details: ['待人友善'], advice: ['保持乐观'] },
    fengshui: { score: 68, overview: '风水尚可', details: ['环境舒适'], advice: ['适当调整'] },
  },
  turningPoints: [
    { year: 2020, type: 'peak' as const, reason: '事业高峰', advice: '把握机会', score: 85 },
    { year: 2025, type: 'change' as const, reason: '重大转折', advice: '谨慎决策', score: 70 },
  ],
  metadata: {
    model: 'gemini',
    generatedAt: new Date(),
    generationTime: 1500,
  },
};

describe('AIClient', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    mockFetch.mockReset();
  });

  describe('构造函数和配置', () => {
    it('应该使用默认配置创建 Gemini 客户端', () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey });
      expect(client).toBeInstanceOf(AIClient);
    });

    it('应该使用自定义配置创建客户端', () => {
      const client = createAIClient({
        model: 'deepseek',
        customApiKey: testApiKey,
        maxRetries: 5,
        timeout: 60000,
      });
      expect(client).toBeInstanceOf(AIClient);
    });

    it('应该支持所有四种模型', () => {
      const geminiClient = createAIClient({ model: 'gemini', customApiKey: testApiKey });
      const deepseekClient = createAIClient({ model: 'deepseek', customApiKey: testApiKey });
      const openaiClient = createAIClient({ model: 'gpt-4o', customApiKey: testApiKey });
      const openaiCompatibleClient = createAIClient({ model: 'openai-compatible', customApiKey: testApiKey });

      expect(geminiClient).toBeInstanceOf(AIClient);
      expect(deepseekClient).toBeInstanceOf(AIClient);
      expect(openaiClient).toBeInstanceOf(AIClient);
      expect(openaiCompatibleClient).toBeInstanceOf(AIClient);
    });
  });

  describe('API 调用', () => {
    it('应该成功调用 Gemini API', async () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          candidates: [{
            content: {
              parts: [{
                text: JSON.stringify(mockAIResponse),
              }],
            },
          }],
        }),
      } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.retries).toBe(0);
      expect(mockFetch).toHaveBeenCalledTimes(1);
    });

    it('应该成功调用 DeepSeek API', async () => {
      const client = createAIClient({ model: 'deepseek', customApiKey: testApiKey });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          choices: [{
            message: {
              content: JSON.stringify(mockAIResponse),
            },
          }],
        }),
      } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('应该成功调用 OpenAI API (GPT-4o)', async () => {
      const client = createAIClient({ model: 'gpt-4o', customApiKey: testApiKey });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          choices: [{
            message: {
              content: JSON.stringify(mockAIResponse),
            },
          }],
        }),
      } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('应该成功调用 OpenAI 兼容 API', async () => {
      const client = createAIClient({
        model: 'openai-compatible',
        customApiKey: testApiKey,
        customEndpoint: 'https://api.example.com/v1/chat/completions',
      });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          choices: [{
            message: {
              content: JSON.stringify(mockAIResponse),
            },
          }],
        }),
      } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      // 验证使用了自定义端点
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('api.example.com'),
        expect.any(Object)
      );
    });

    it('应该支持自定义模型名称（OpenAI 兼容）', async () => {
      const client = createAIClient({
        model: 'openai-compatible',
        customApiKey: testApiKey,
      });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          choices: [{
            message: {
              content: JSON.stringify(mockAIResponse),
            },
          }],
        }),
      } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(true);
      // 验证请求体中包含模型名称
      const fetchCall = mockFetch.mock.calls[0];
      const requestBody = JSON.parse(fetchCall[1].body);
      expect(requestBody.model).toBeDefined();
    });
  });

  describe('重试机制', () => {
    it('应该在失败时自动重试', async () => {
      // 重置 mock
      mockFetch.mockReset();
      mockFetch.mockClear();

      const client = createAIClient({
        model: 'gemini',
        customApiKey: testApiKey,
        maxRetries: 3,
      });

      // 前两次失败,第三次成功
      mockFetch
        .mockRejectedValueOnce(new Error('Network error'))
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({
            candidates: [{
              content: {
                parts: [{
                  text: JSON.stringify(mockAIResponse),
                }],
              },
            }],
          }),
        } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(true);
      expect(result.retries).toBe(2);
      expect(mockFetch).toHaveBeenCalledTimes(3);
    });

    it.skip('应该在达到最大重试次数后失败', async () => {
      // 重置 mock
      mockFetch.mockReset();
      mockFetch.mockClear();

      const client = createAIClient({
        model: 'gemini',
        customApiKey: testApiKey,
        maxRetries: 2,
      });

      // 所有尝试都失败
      mockFetch.mockRejectedValue(new Error('Network error'));

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
      expect(mockFetch).toHaveBeenCalledTimes(3); // 初始调用 + 2次重试
    });

    it.skip('应该使用指数退避策略', async () => {
      const client = createAIClient({
        model: 'gemini',
        customApiKey: testApiKey,
        maxRetries: 2,
      });

      const startTime = Date.now();
      let callCount = 0;

      mockFetch.mockImplementation(async () => {
        callCount++;
        if (callCount < 3) {
          throw new Error('Network error');
        }
        return {
          ok: true,
          json: async () => ({
            candidates: [{
              content: {
                parts: [{
                  text: JSON.stringify(mockAIResponse),
                }],
              },
            }],
          }),
        } as Response;
      });

      await client.analyzeBazi(mockBaziResult);
      const duration = Date.now() - startTime;

      // 指数退避: 1秒 + 2秒 = 至少3秒
      expect(duration).toBeGreaterThan(2500);
    });
  });

  describe.skip('错误处理', () => {
    it('应该处理网络错误', async () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey, maxRetries: 0 });

      mockFetch.mockRejectedValueOnce(new Error('Network error'));

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Network error');
    });

    it.skip('应该处理超时错误', async () => {
      const client = createAIClient({
        model: 'gemini',
        customApiKey: testApiKey,
        maxRetries: 0,
        timeout: 100,
      });

      mockFetch.mockImplementationOnce(() =>
        new Promise((resolve) => setTimeout(resolve, 200))
      );

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(false);
      expect(result.error).toContain('超时');
    });

    it.skip('应该处理 HTTP 错误响应', async () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey, maxRetries: 0 });

      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        json: async () => ({ error: 'Internal server error' }),
      } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.success).toBe(false);
      expect(result.error).toContain('500');
    });

    it.skip('应该处理无效的 JSON 响应', async () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey, maxRetries: 0 });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          candidates: [{
            content: {
              parts: [{
                text: 'invalid json{{{',
              }],
            },
          }],
        }),
      } as Response);

      const result = await client.analyzeBazi(mockBaziResult);

      // 应该触发重试机制
      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('连接测试', () => {
    it('应该成功测试连接', async () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ candidates: [] }),
      } as Response);

      const result = await client.testConnection();

      expect(result.success).toBe(true);
    });

    it('应该在连接失败时返回错误', async () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey });

      mockFetch.mockRejectedValueOnce(new Error('Connection failed'));

      const result = await client.testConnection();

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('便捷函数', () => {
    it.skip('quickAnalyze 应该使用默认客户端', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          candidates: [{
            content: {
              parts: [{
                text: JSON.stringify(mockAIResponse),
              }],
            },
          }],
        }),
      } as Response);

      const result = await quickAnalyze(mockBaziResult);

      expect(result.success).toBe(true);
    });

    it('getDefaultClient 应该返回可用的客户端', () => {
      const client = getDefaultClient();
      expect(client).toBeInstanceOf(AIClient);
    });
  });

  describe.skip('性能监控', () => {
    it('应该记录调用耗时', async () => {
      const client = createAIClient({ model: 'gemini', customApiKey: testApiKey });

      mockFetch.mockImplementationOnce(async () => {
        // 模拟100ms延迟
        await new Promise(resolve => setTimeout(resolve, 100));
        return {
          ok: true,
          json: async () => ({
            candidates: [{
              content: {
                parts: [{
                  text: JSON.stringify(mockAIResponse),
                }],
              },
            }],
          }),
        } as Response;
      });

      const result = await client.analyzeBazi(mockBaziResult);

      expect(result.duration).toBeGreaterThanOrEqual(100);
      expect(result.duration).toBeLessThan(500);
    });
  });
});
